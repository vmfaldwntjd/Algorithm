문제에서 각 집의 좌표가 최대 10억 즉, 탐색할 수 있는 최대 범위가 10억이므로 이진 탐색을 사용하여 문제를 해결해야 합니다.
그리고 문제에서 '가장 인접한 두 공유기 사이의 거리의 최댓값'을 구해야 하므로 그것을 탐색하는 방식으로 구현하면 됩니다.
문제의 예시를 바탕으로 설명하면 다음과 같습니다.

1. 문제의 예시를 바탕으로 설명을 하자면 [1, 2, 8, 4, 9]의 좌표를 담은 리스트를 만든 다음 이진 탐색을 수행해야 하므로 오름차순으로 정렬합니다.  
   -> 그러면 [1, 2, 4, 8, 9]의 상태가 됩니다.

2. 가장 인접한 두 공유기 사이의 거리의 적절한 값 gap을 탐색하기 위해서 **가능한 최소 gap인 min_gap과 현재 좌표에서 가능한 최대 gap인 max_gap을 설정합니다.**  
   -> 그려면 min_gap은 1인 경우가 되고(인접한 두 집의 가능할 수 있는 최소 거리는 1이므로), max_gap은 9 - 1 = 8 인 상태입니다.

3. 공유기 설치를 위해서 선택된 좌표를 붉은색으로 처리하겠습니다. 현재 가능한 min_gap은 1, max_gap은 8 이므로 **이 둘의 중간값인 gap을 4로 설정을 합니다.**
   이는 공유기의 설치 간격의 최솟값을 gap으로 하겠다는 의미입니다. 이를 이용하여 공유기 설치를 **첫 번째 원소부터 시작하여 gap만큼의 간격으로 설치를 진행**합니다. 그러면 설치된 공유기의 좌표는 다음과 같습니다.  
   -> [<style>1{color:red;}</style>, 2, 4, 8, 9]

4. 위 경우에서 설치된 공유기의 개수는 문제에서 공유기의 개수 c = 3보다 작으므로 인접한 공유기의 설치 간격을 좀 더 좁혀야 합니다. 즉, 공유기의 max_gap을 gap - 1로 업데이트 하여 다시 탐색을 진행합니다.  
   -> min_gap = 1, max_gap = gap - 1 = 3, gap = (min_gap + max_gap) // 2 = 2

5. 이제 다시 gap = 2를 바탕으로 공유기를 설치해보면 다음과 같습니다.  
   -> [1, 2, 4, 8, 9]  
   -> 공유기의 개수는 설치할 수 있는 공유기의 개수 c보다 같으므로 gap이 더 커졌을 때도 공유기를 3개가 설치 가능한지 확인해야 한다. 즉, min_gap = gap + 1 = 3으로 업데이트 한다.  
   -> 그러면 현재 min_gap = 3, max_gap = 3, gap = 3이 된다.

6. gap = 3을 바탕으로 공유기를 설치해보면 다음과 같습니다.  
   -> [1, 2, 4, 8, 9]  
   -> 이 역시 공유기 3개가 설치가 가능하고 다시 min_gap을 업데이트하면 min_gap이 max_gap보다 커지는 상황이 발생해서 gap = 3이 최적의 해가 되는 것입니다.
