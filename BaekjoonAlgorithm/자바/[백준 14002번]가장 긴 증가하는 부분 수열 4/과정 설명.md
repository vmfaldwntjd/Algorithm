문제 링크: https://www.acmicpc.net/problem/14002  
다이나믹 프로그래밍 문제로 dp(dynamic programming) table을 만들어서 문제를 해결해야 합니다.  
문제에 있는 예시인 부분 수열 A = (10, 20, 10, 30, 20, 50)을 바탕으로 설명 하겠습니다.  
점화식 d[N]을 N번째까지의 수 중에서 가장 긴 부분 수열의 길이라고 정의하고 수열 A를 첫 번째 부터 살펴가면 다음과 같은 표를 만들 수가 있습니다.  
그리고 수열의 결과도 출력해야 하므로 N번째까지의 증가하는 수열의 길이를 나타내는 위치의 그 앞 위치 정보를 담고 있는 v[N]의 배열도 만들어줍니다.  
- - -
첫 번째 인덱스를 살펴봤을 때
| idx | 1 | 2 | 3 | 4 | 5 | 6 |
|-----|-----|-----|-----|-----|-----|-----|
| A | 10 | 20 | 10 | 30 | 20 | 50 |
| d | 1 | 1 | 1 | 1 | 1 | 1 |
| v | -1 | -1 | -1 | -1 | -1 | -1 |

-> 첫 번째 인덱스만 살펴보고 나머지는 아직 살피지 않은 상태이므로 1로 둡니다. 자기 자신 혼자도 증가하는 수열로 여길 수 있기 때문입니다.  
-> 그리고 첫 번째 인덱스의 그 전 값은 없으므로 v[1] = -1이 됩니다.  
- - -
두 번째 인덱스를 살펴봤을 때
| idx | 1 | 2 | 3 | 4 | 5 | 6 |
|-----|-----|-----|-----|-----|-----|-----|
| A | 10 | 20 | 10 | 30 | 20 | 50 |
| d | 1 | 2 | 1 | 1 | 1 | 1 |
| v | -1 | 1 | -1 | -1 | -1 | -1 |

-> 첫 번째 인덱스가 두 번째 인덱스보다 작으므로 증가하는 수열이 성립이 됩니다. 
-> 현재 두 번째 자리에 있는 d의 값과 첫 번째 d의 값을 더한 결과는 d[2] + d[1] = 2가 됩니다.  
-> 이는 현재 처음의 d[2]의 값 1보다 큰 값이므로 d[2] = 2로 업데이트 해줍니다.  
-> 그리고 v[2] = 1로 그 전 인덱스 위치 정보를 표시해줍니다.  
- - -
세 번째 인덱스를 살펴봤을 때  
| idx | 1 | 2 | 3 | 4 | 5 | 6 |
|-----|-----|-----|-----|-----|-----|-----|
| A | 10 | 20 | 10 | 30 | 20 | 50 |
| d | 1 | 2 | 1 | 1 | 1 | 1 |
| v | -1 | 1 | -1 | -1 | -1 | -1 |

-> 두 번째 인덱스와 봤을 때 오름차순이 성립하지 않으므로 첫 번째 인덱스로 넘어갑니다.  
-> 첫 번째 인덱스도 마찬가지로 오름차순이 성립이 되지 않으므로 그냥 다음 인덱스로 넘어갑니다.  
- - -
네 번째 인덱스를 살펴봤을 때  
| idx | 1 | 2 | 3 | 4 | 5 | 6 |
|-----|-----|-----|-----|-----|-----|-----|
| A | 10 | 20 | 10 | 30 | 20 | 50 |
| d | 1 | 2 | 1 | 3 | 1 | 1 |
| v | -1 | 1 | -1 | 2 | -1 | -1 |

-> 세번 째 인덱스와 살펴봤을 때 오름차순이 성립이 되므로 d[4] + d[3] = 2가 됩니다.  
-> 이 값은 현재 d[4] = 1보다 크므로 2를 d[4]를 새로 업데이트할 후보에 담아둡니다.  
-> 두번 째 인덱스를 살펴봤을 때 오름차순이 성립이 되므로 d[4] + d[2] = 1 + 2 = 3이 됩니다.  
-> 3역시 d[4] = 1보다 크므로 d[4]를 새로 업데이트할 후보에 담아둡니다.  
-> 이렇게 첫 번째 인덱스까지 반복하다 보면 제일 큰 후보는 3이므로 d[4] = 3으로 업데이트 합니다.  
- - -
최종 결과 표
| idx | 1 | 2 | 3 | 4 | 5 | 6 |
|-----|-----|-----|-----|-----|-----|-----|
| A | 10 | 20 | 10 | 30 | 20 | 50 |
| d | 1 | 2 | 1 | 3 | 2 | 4 |
| v | -1 | 1 | -1 | 2 | 3 | 4 |

-> 이렇게 만든 d에서 최댓값을 구하면 가장 긴 부분 수열의 길이를 구할 수가 있습니다.  
-> 그리고 v를 통해서 가장 긴 부분 수열의 위치를 이용해 A[6] -> A[v[6]] -> A[v[4]] -> A[v[2]] -> ... 방식으로 재귀 함수를 이용해서 출력하면 됩니다.  