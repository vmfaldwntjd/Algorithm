문제 링크: https://www.acmicpc.net/problem/13398
- - -
> 고찰 및 해결 과정  
- 어떻게 해결해야할지 고민을 꽤 많이 했었던 문제이다.  
- 그리고 예외처리를 하는 데도 시간이 많이 걸렸다.  
- 이 문제는 단순히 배열을 일일이 돌면서 각 위치의 값을 하나씩 제거했을 때의 연속합을 일일이 구하면 시간초과가 걸린다.  
- 값 하나를 제거했을 때의 연속합을 구해야 하기 때문에 이중 반복문을 사용해야하고 n의 최댓값은 10만이므로 시간 복잡도 O(n^2)에는 시간초과가 난다.  
- 이 문제는 다이나믹 프로그래밍 문제긴 하나 dp테이블 하나로 해결할 수는 없다.  
- 어떤 기준값 하나를 기준으로 해당 값까지의 연속된 수들 중에서의 최댓값을 구하는 경우랑 기준값을 시작으로 연속된 수들 중에서 최댓값을 구하는 경우의 2가지 dp테이블을 만들어야 한다.  
- 나는 그 dp 테이블을 각각 d_left, d_right라고 이름 지었다. 정의는 다음과 같이 지었다.  
  -> ```d_left[n] : n까지 왼쪽부터 연속된 수들의 합의 최댓값, d_right[n] : n까지 오른쪽부터 연속된 수들의 합의 최댓값```  
- 문제 예시에 있는 배열 A(10 -4 3 1 5 6 -35 12 21 -1)을 기준으로 설명하겠다.  
- 해당 정의에 따라서 d_left[n], d_right[n]테이블을 정리하면 다음과 같다.  
  -> d_left테이블  
  | idx | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
  |-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
  | A | 10 | -4 | 3 | 1 | 5 | 6 | -35 | 12 | 21 | -1 |
  | d_left | 10 | 6 | 9 | 10 | 15 | 21 | -14 | 12 | 33 | 32 |

  -> d_right테이블  
  | idx | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
  |-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
  | A | 10 | -4 | 3 | 1 | 5 | 6 | -35 | 12 | 21 | -1 |
  | d_left | 10 | 6 | 9 | 10 | 15 | 21 | -14 | 12 | 33 | 32 |

  -> 이 테이블이 어떻게 만들어졌는지 자세히 알고 싶으면 [가장 긴 증가하는 부분 수열](https://github.com/vmfaldwntjd/Algorithm/blob/master/BaekjoonAlgorithm/%EC%9E%90%EB%B0%94/%5B%EB%B0%B1%EC%A4%80%2011053%EB%B2%88%5D%EA%B0%80%EC%9E%A5%20%EA%B8%B4%20%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94%20%EC%88%98%EC%97%B4/%EA%B3%BC%EC%A0%95%20%EC%84%A4%EB%AA%85.md)을 참고하면 된다. d_left를 구하는 방법이랑 똑같다.  

- 이제 다시 배열 A에 집중해보자.  
- 배열을 순회하는 인덱스를 i라고 했을 때 i가 가리키고 있는 그 값을 제거한다면 연속합의 최댓값은 다음과 같이 정의할 수 있다.  
  -> ```d_left[i - 1] + d_right[i + 1]```  
- 결국은 순회하면서 A[i]의 값이 존재할 때랑 존재하지 않을 때의 경우 중 최댓값을 구하면 되는 것이다.  
  -> ```max(d_left[i - 1] + d_right[i + 1], d_left[i])```  
  