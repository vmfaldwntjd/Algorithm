문제 링크: https://www.acmicpc.net/problem/13398
- - -
> 고찰 및 해결 과정  
- 어떻게 해결해야할지 고민을 꽤 많이 했었던 문제이다.  
- 그리고 예외처리를 하는 데도 시간이 많이 걸렸다.  
- 이 문제는 단순히 배열을 일일이 돌면서 각 위치의 값을 하나씩 제거했을 때의 연속합을 일일이 구하면 시간초과가 걸린다.  
- 값 하나를 제거했을 때의 연속합을 구해야 하기 때문에 이중 반복문을 사용해야하고 n의 최댓값은 10만이므로 시간 복잡도 O(n^2)에는 시간초과가 난다.  
- 이 문제는 다이나믹 프로그래밍 문제긴 하나 dp테이블 하나로 해결할 수는 없다.  
- 어떤 기준값 하나를 기준으로 해당 값까지의 연속된 수들 중에서의 최댓값을 구하는 경우랑 기준값을 시작으로 연속된 수들 중에서 최댓값을 구하는 경우의 2가지 dp테이블을 만들어야 한다.  
- 나는 그 dp 테이블을 각각 d_left, d_right라고 이름 지었다. 정의는 다음과 같이 지었다.  
  -> ```d_left[n] : n까지 왼쪽부터 연속된 수들의 합의 최댓값, d_right[n] : n까지 오른쪽부터 연속된 수들의 합의 최댓값```  
- 문제 예시에 있는 (10 -4 3 1 5 6 -35 12 21 -1)을 기준으로 설명하겠다.  
- 해당 정의에 따라서 d_left[n], d_right[n]테이블을 정리하면 다음과 같다.  
  -> d_left테이블  
  | idx | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
  |-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
  | A | 10 | -4 | 3 | 1 | 5 | 6 | -35 | 12 | 21 | -1 |
  | d_left | 10 | 6 | 9 | 10 | 15 | 21 | -14 | 12 | 33 | 32 |

  -> d_right테이블  
  | idx | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
  |-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
  | A | 10 | -4 | 3 | 1 | 5 | 6 | -35 | 12 | 21 | -1 |
  | d_left | 10 | 6 | 9 | 10 | 15 | 21 | -14 | 12 | 33 | 32 |
