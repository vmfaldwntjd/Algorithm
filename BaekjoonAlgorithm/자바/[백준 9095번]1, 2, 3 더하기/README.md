문제 링크: https://www.acmicpc.net/problem/9095  
- - - 
## 고찰 및 해결 과정  
### 방법1
- 정수 n의 범위는 1 <= n < 11 이므로 n이 1인 경우부터 차근차근 생각해보았다.  
- d[n]을 n을 1, 2, 3의 합으로 나태내는 방법의 수라고 가정해보자.  
  -> n이 1일 때 1, 2, 3으로 나타낼 수 있는 방법의 수는 1 한 가지이다.  
  -> n이 2인 경우는 2가지의 경우가 가능하다.  
  ```
  - 1 + 1
  - 2
  ```
  -> n이 3인 경우는 4가지의 경우가 가능하다.  
  ```
  - 1 + 1 + 1
  - 2 + 1
  - 1 + 2
  - 3
  ```
  -> n이 4인 경우는 다음과 같이 7가지 경우가 가능하다.  
  ```
  - 1 + 1 + 1 + 1
  - 1 + 2 + 1
  - 2 + 1 + 1
  - 3 + 1
  - 1 + 1 + 2
  - 2 + 2
  - 1 + 3
  ```
- n이 4인 경우를 자세히 덧셈식의 맨 마지막 숫자를 제외하고 살펴보면 다음과 같이 구성이 되어 있음을 알 수가 있다.  
  -> ```d[4] = d[3] + d[2] + d[1]```
- 이를 바탕으로 점화식을 세워보면 다음과 같다.  
  -> ```d[n] = d[n - 1] + d[n - 2] + d[n - 3], (4 <= n < 11)```
- - -

## 방법 2
- 이 방법은 참고한 방법이다.  
- 재귀호출 방식을 통해서 문제를 해결할 수가 있다.  
- 예를 들어서 특정 자연수 n을 만들기 위해서 n보다 작고 지금까지 자연수들을 더해서 만들어진 현재 자연수 temp에 나머지 자연수 i를 더하면 자연수 n이 되는 상황이 있다고 가정해보자.  
  -> temp + i = n  
- temp에 i를 더하는 경우의 방식을 재귀호출의 방법을 통해서 해결할 수가 있다.  
- 코드를 통해서 설명을 하겠다. 다음 코드는 재귀 함수 print에 대한 내용이다. 설명은 주석을 통해서 하겠다.  
  ```JAVA
  public static int print(int sum, int goal) { //파라미터에서 goal은 합을 통해서 만들어야 할 자연수이고, sum은 현재까지 더해진 자연수의 결과이다.  
        if (sum > goal) //계속 더하다 보면 sum이 goal을 넘어가는 경우가 있을 수도 있어서 예외처리
            return 0;
        if (sum == goal) //sum이 goal과 같아진다면 목표 자연수 goal에 도달했다는 얘기가 되므로 하나의 경우를 찾은 것이다. 
            return 1;
        int now = 0; //결과를 반환할 변수
        for (int i = 1; i <= 3; ++i)
            now += print(sum + i, goal); //처음에 sum은 0인 상태이다.  
        return now;
    }
  ```
- 나는 이 코드를 디버깅을 하면서 이해를 하였다.  