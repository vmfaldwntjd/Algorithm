문제 링크: https://www.acmicpc.net/problem/1697
- - -
# 고찰 및 해결 과정
- 지정된 위치에 도달하기까지 걸리는 최소 시간을 구하는 문제이므로 **bfs 알고리즘을 사용**하면 문제를 해결할 수 있다.  
- 문제에서 수빈이와 동생은 일직선 상에 있으므로 N과 K의 최댓값이 각각 100000이므로 bfs알고리즘을 사용했을 때 걸릴 수 있는 시간의 최악의 경우를 생각을 해봤을 때 시간 복잡도는 **O(N)**이다. 이는 제한 시간 2초 내에 문제를 해결하기에는 충분한 시간이다.  
- 이 때 수빈이가 순간이동을 하는 경우 이동할 수 있는 위치의 최댓값이 200000인데 동생은 최대 100000위치에 있으므로 거리 상으로 100000지점을 넘는 곳을 순간이동 하는 경우가 있다면 이것은 **어느 상황이든 비효율적인 이동 방식이 되어 버린다.**  
- 예를 들어서 동생의 위치가 100000에 있다고 하고 수빈이의 위치가 50001에 있다고 가정한다면 ```50001 * 2 - 1 - 1```을 통해서 총 3초에 걸쳐서 동생의 위치를 찾는 것 보다 ```50001 - 1 * 2```를 통해 2초에 걸쳐서 동생의 위치를 찾는 것이 더 효율적이다.  
- 따라서 특정 지점에 이동하기까지의 시간 정보를 담는 배열을 dist라고 가정하면 dist의 최대 크기를 100001로 지정할 수가 있다. (인덱스 100000포함)  
- 문제 해결 과정의 큰 틀은 다음과 같다.  
    - 특정 지점에 이동하기까지의 시간 정보를 담는 배열 dist를 처음에는 -1로 초기화 한다.  dist의 사이즈는 배열 기준 100001이고 -1의 의미는 수빈이가 아직 해당 지점에 도달하지 않았다는 의미이다.  
    - bfs알고리즘을 활용해서 dist의 내용을 업데이트 한다.  
    - 동생의 위치를 찾았다면 동생의 지점에 도달하기까지 걸리는 시간 dist[k]를 출력하면 정답을 도출할 수 있다.  