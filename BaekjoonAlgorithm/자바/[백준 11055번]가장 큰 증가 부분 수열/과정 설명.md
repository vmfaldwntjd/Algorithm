문제 링크: https://www.acmicpc.net/problem/11055
- - -
> 고찰 및 해결 과정 
- LIS를 응용한 문제로 다이나믹 프로그래밍 문제이다.  
- ***가장 긴 것이 아니라 합이 가장 큰 것***이므로 이 부분만 유의하면서 해결하면 된다.  
> 그림을 통한 설명  
- 수열을 담은 배열을 A이라고 하고, d[n]을 n번 째 자리에서 나올 수 있는 최대합이라고 정의를 하고 각각 테이블을 만들어준다. 각각의 테이블의 초기값은 다음과 같다.  

| idx | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|----|----|----|----|----|----|----|----|----|----|----|
| A | 1 | 100 | 2 | 50 | 60 | 3 | 5 | 6 | 7 | 8 |
| d | 1 | 100 | 2 | 50 | 60 | 3 | 5 | 6 | 7 | 8 |

- - -
- idx = 1을 살펴봤을 때는 자기 자신이 수열의 최댓값이 되므로 idx = 2부터 살펴보도록 하겠다.  

| idx | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|----|----|----|----|----|----|----|----|----|----|----|
| A | 1 | 100 | 2 | 50 | 60 | 3 | 5 | 6 | 7 | 8 |
| d | 1 | 101 | 2 | 50 | 60 | 3 | 5 | 6 | 7 | 8 |

-> 그 이전의 인덱스 1과 비교했을 때 오름차순이 성립이 되고 idx = 1자리의 A의 값을 더한 101이 최댓값이 되므로 d[2] = 101이 된다.  

- - -
- idx = 3일 때 

| idx | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|----|----|----|----|----|----|----|----|----|----|----|
| A | 1 | 100 | 2 | 50 | 60 | 3 | 5 | 6 | 7 | 8 |
| d | 1 | 101 | 3 | 50 | 60 | 3 | 5 | 6 | 7 | 8 |

-> A[2]와 비교했을 때는 오름차순이 성립이 되지 않고 A[1]과는 오름차순이 성립 되므로 이 둘을 더한 값이 현재 자리에서의 큼 값이 된다. 즉 d[3] = d[1] + d[3] = 1 + 2 = 3이 된다. 

- - -
- idx = 4일 때  

| idx | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|----|----|----|----|----|----|----|----|----|----|----|
| A | 1 | 100 | 2 | 50 | 60 | 3 | 5 | 6 | 7 | 8 |
| d | 1 | 101 | 3 | 53 | 60 | 3 | 5 | 6 | 7 | 8 |

-> A[4]와 비교했을 때 오름차순이 성립되는 인덱스는 A[3], A[1]이다. 즉 d[4] = max(d[3] + d[4], d[1] + d[4]) = 53이다.  

- - -
- 이런 방식을 거듭해서 idx = 10에 도달했을 때 최종적인 표는 다음과 같다.  

| idx | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
|----|----|----|----|----|----|----|----|----|----|----|
| A | 1 | 100 | 2 | 50 | 60 | 3 | 5 | 6 | 7 | 8 |
| d | 1 | 101 | 3 | 53 | 113 | 6 | 11 | 17 | 24 | 32 |

-> 결국 ***d가 가지고 있는 값들 중에서 최댓값을 구하면*** 가장 큰 증가하는 수열이 된다!

