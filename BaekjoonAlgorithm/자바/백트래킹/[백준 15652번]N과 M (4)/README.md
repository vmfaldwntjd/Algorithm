문제링크: https://www.acmicpc.net/problem/15652  
- - -
# 고찰 및 해결과정
## 첫 번째 방법(Main.java)
- 이 문제는 N까지의 자연수들 중에서 M개를 선택하는데 오름차순이면서 중복이 가능한 "비내림차순"형태로 수열을 만들어야 한다.  
- 나는 이 문제를 재귀함수를 사용해서 해결하였다.  
- 코드로 주석을 첨부하면서 문제를 설명하겠다. 다음 코드는 재귀 호출을 하는 함수의 내용이다.  
```JAVA
public static void print(int[] arr, int idx, int start, int n, int m) throws IOException {
        if (idx >= m) { //만약 idx가 m을 가리키고 있다면 이미 m개만큼 arr이 다 찼다는 얘기가 된다.  
            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
            for (int i = 0; i < m; ++i) { //수열 출력 부분
                bw.write(arr[i] + " ");
            }
            bw.write("\n");
            bw.flush();
            return;
        }

        for (int i = start; i <= n; ++i) {//i의 시작점을 start로 지정한다. 비내림차순 유지를 하기 위함이다. 
                arr[idx] = i; //특정 위치에 어떤 수를 담았으면 이제 재귀 호출을 한다.  
                print(arr,idx + 1, i, n, m); //특정 자리에 수를 넣었으니 idx를 업데이트 하고, start자리에는 자기 자신의 수를 넣는다.  
                arr[idx] = 0; //재귀 호출이 끝났으면 이미 수열 출력을 완료했다는 의미이므로 현재 자리는 다시 원래 수로 초기화 한다.  
            }
        }
```
  -> arr은 특정 수열을 담기 위한 배열이다.  
  -> idx는 특정 수를 담을 arr의 위치를 가리킬 변수이다.  
  -> start는 "비내림차순"의 수열을 유지하기 위해서 사용되는 변수이다.  
  -> 예를 들어 어떤 4자리 수열 _ _ _ _가 있을 때 1 _ _ _에서 1다음에 올 수 있는 숫자는 1과 같은 수이면서 큰 수이다.  
  -> 1 다음에 오는 자리의 수를 담기 위한 기준 역할을 하는 것이 start이다.  
- - -
## 두 번째 방법(Main2.java)
- 첫 번째 방법에 비하면 좀 복잡한 방법이다.  
- 나는 첫 번째 방식으로 풀었고 두 번째 방법의 코드는 참고하면서 작성한 것이다.  
- 비내림차순을 만들기 위해서 어떤 수들을 나열한다고 했을 때 각각의 수를 선택하는지 또는 선택하지 않는지의 경우로 나누어서 설명이 가능하다.  
- 이 방법도 역시 마찬가지로 재귀 함수를 호출해서 문제를 해결하였다.  
- 이 코드에서 StringBuilder객체를 사용하였는데 출력하는 방법으로 재귀 호출을 사용하면 시간초과가 걸리기 때문에 사용하였다.  
- 재귀 호출을 사용한 함수 코드를 첨부하면서 설명하겠다.  
  ```JAVA
  public static StringBuilder print(int[] cnt, int num, int selected, int n, int m) { //처음에 num은 1부터 시작하고, selected는 0부터 시작이 된다.  
        if (selected >= m) { //selected가 m과 같아지면 m번 출력해야할 공간이 다 찼다는 걸 의미하므로 수열을 출력해야 한다. 
            StringBuilder sb = new StringBuilder();
            for (int i = 1; i <= n; ++i) { //이중 반복문을 통해서 i를 cnt번 출력하도록 설정하였다.
                for (int j = 0; j < cnt[i]; ++j)
                    sb.append(i + " ");
            }
            sb.append("\n");
            return sb;
        }

        StringBuilder result = new StringBuilder();
        if (num > n) //아무도 선택되지 않은 상태에서 num이 n을 넘어가는 경우가 있다. 그래서 예외처리
            return result;
        for (int i = m - selected; i >= 1; --i) {
            //특정 숫자를 선택했을 때의 영역
            cnt[num] = i;
            result.append(print(cnt, num + 1, selected + i, n, m));
        }
        //숫자가 선택되지 않았을 때의 영역
        cnt[num] = 0;
        result.append(print(cnt, num + 1, selected, n, m));
        return result;
    }
  ```
  ### cnt 배열의 역할
    -> cnt 배열은 첫 방법의 arr배열과는 다르다. 이것은 **특정 숫자를 몇번 출력할지를 정할 배열이다.**  
    -> 예를 들어서 **cnt[i] = 4**는 **i를 4번 출력**하라는 말과 같다.  
  ### if (num > n)의 역할
    -> ```if (num > n)```조건을 달아준 이유는 어떤 수열 중 **특정 수들이 모두 선택되지 않았을 때 num이 n을 넘어가는 경우**가 있는데 이를 방지하기 위해 **예외처리**를 하였다.  
    -> 예를 들어 어떤 4자리의 수열을 1~4의 자연수로 출력을 한다고 가정해보자.  
    -> 1, 2, 3, 4각 숫자가 빈칸의 수열 _ _ _ _ 에 들어갈 수 있는 경우에서 선택된 것과 선택되지 않은 모든 경우의 수를 고려할 때 모두 선택되지 않은 경우의 수가 있다.  
    -> 그러면 num은 4인 상태일텐데 다시 재귀호출을 하면 num이 5가 되어서 n값보다 커지게 되므로 이는 따로 예외처리를 해줘야 한다.  
    -> 디버깅을 하면서 코드의 흐름을 파악하면 이해가 될 것이다.  
  ### for (int i = m - selected; i >= 1; --i)의 조건 설정 원리
    -> 이는 첫 번째의 경우부터 차근차근 생각하면 다음과 같은 원리를 이해하는데 쉬울 것이다.  
    -> 예를 들어서 4자리의 수열을 자연수 1~4를 활용하여 출력하는 경우를 생각해보자.  
    -> 그러면 우선 제일 처음 나와야 하는 경우는 1 1 1 1이다. 
    -> 이 경우를 봤을 때 1이 4번 나오는 경우를 볼 수 있는데 그러면 처음에 **cnt[1] = 4**로 설정이 되었을 것이다.  
    -> ``` result.append(print(cnt, num + 1, selected + i, n, m));```부분을 보면 num을 1더하여 다음 숫자로 업데이트하고, selected를 selected + i를 통해서 업데이트 한 것을 볼 수가 있는데 **이는 1이 선택이 되었다는 것을 의미**한다.  
    -> selected에서 **i(i는 m과 같은 값에서 시작한다는 것을 명심)를 더해준 이유**는 코드의 흐름으로 보면 이해가 되는데 cnt[1] = 4이고 4는 m과 같아서 출력을 해야한다.  
    -> 그러면 **종료 조건에서 수열을 출력을 해줘야** 하는데 selected + 1을 하면 종료 조건에 들어갈 수가 없으므로 **selected + i를 통해서 수열을 다 출력할 수 있도록 설정**한 것이다.  
    -> 결론적으로 말하자면 **같은 숫자(예시의 1과 같은 경우)를 처음에는 4번 출력을 해야하므로** i가 4로 먼저 초기화가 된 것이라고 보면 된다. 이것은 코드의 흐름을 보면서 분석하면 더 쉽게 이해가 될 것이다.  
