이 문제는 **시간이 적게 걸리는 음식부터 확인하는 그리디 방식을 적용**해서 문제를 해결하였습니다. 그러기 위해서 우선순위 큐를 사용하였는데, (음식 시간, 음식 번호)의 형식으로 우선순위 큐에 넣은 다음 음식 시간이 제일 적은 음식부터 제거해나가는 방식을 적용합니다. 문제의 예시를 바탕으로 설명해보겠습니다.  
food_times = [3, 1, 2]  
k = 5  
q = priority()

1. 위의 예시에서 **food_times의 원소들의 합이 k보다 작거나 같다면 -1을 반환**하고, 그렇지 않다면 우선순위 큐에 적용을 합니다. 큐에 있는 내용은 다음과 같습니다. (음식시간, 음식번호) -> q = priority((1, 2), (2, 3), (3, 1))

2. food_times의 길이는 3이므로, q의 첫 번째 원소의 음식이 다 제거될 때까지 걸리는 시간은 **1(음식 시간) \* 3(food_tims의 길이)이것이 k보다 큰지 확인**합니다. 그렇지 않다면 q의 첫 번째 원소를 꺼내어 음식을 제거하는데 걸리는 시간을 세어주고, 음식의 길이는 하나 줄어드므로 2가 됩니다. -> q = priority((2, 3), (3, 1))

3. 다음으로 큐에 남아있는 첫 번째 원소를 꺼내기 전에 이 음식 제거 시간이 k보다 작거나 같은지 확인을 합니다. k보다 작거나 같다면 마찬가지로 **(음식시간) \* (현재 음식 개수)**만큼 시간을 세어주고 음식의 길이는 또 하나 빼줍니다. -> q = priority((3, 1))

4. 마지막 원소는 계산시 k보다 커지므로 우선순위 큐에서 뽑지 않고, 그대로 냅둡니다. 그러면 현재 큐에 있는 원소는 (3, 1)이므로 음식 번호 1번을 출력하면 됩니다.
